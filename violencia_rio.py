# -*- coding: utf-8 -*-
"""violencia_rio.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1UnMxwuAZVtoFdLxMs2EHZC4x8Ze36tNM

Os dados sobre a violencia no Rio de Janeiro estão nesse link: https://drive.google.com/file/d/1lKqvthdfJhAgGnbQCuUtv3NeJrT4NAnG/view?usp=drive_link

Site aonde se encontra os dados de segurança: http://www.ispdados.rj.gov.br/estatistica.html

Dicionario: http://www.ispdados.rj.gov.br/divisaoTerritorial.html

Link dos csv: https://drive.google.com/file/d/18EX0DMOTANiLaISXn3shFCQzw9M0T3yL/view?usp=drive_link, https://drive.google.com/file/d/1uTVtmdnyvLZdcYXQMOy107jFJ5nSoRSr/view?usp=drive_link, https://drive.google.com/file/d/1lKqvthdfJhAgGnbQCuUtv3NeJrT4NAnG/view?usp=drive_link
"""

from google.colab import drive
drive.mount('/content/drive')

"""Roteiro de extensão: https://docs.google.com/document/d/17aEBOZPbcr6HdKMoYEH-GNZVo7EhloSz1RBYUvpznyk/edit"""

import pandas as pd
import plotly.graph_objects as go
import matplotlib.pyplot as plt
from sklearn.linear_model import LinearRegression
from sklearn.datasets import load_iris
import numpy as np
import seaborn as sns

from google.colab import drive
drive.mount('/content/gdrive')

!cp /content/gdrive/MyDrive/topicosbigdatapython/BaseDPEvolucaoMensalCisp.csv /content

violencia = "/content/BaseDPEvolucaoMensalCisp.csv"

data = pd.read_csv(violencia,encoding="ISO-8859-1",sep= ";")

data['data'] = pd.to_datetime(data['ano'].astype(str) + '-' + data['mes'].astype(str), format='%Y-%m')

roubo_celular = data.groupby(['roubo_celular']).sum()

roubo_veiculo = data.groupby(['roubo_veiculo']).sum()

# Crie um modelo de regressão linear
regressao = LinearRegression()

# Ajuste o modelo aos dados
X = np.array(data['ano']).reshape(-1, 1)
y = data['roubo_carga']
regressao.fit(X, y)

# Preveja os valores usando o modelo ajustado
y_pred = regressao.predict(X)

# Crie um gráfico de dispersão com a linha de regressão
plt.figure(figsize=(10, 5))
plt.scatter(X, y, color='blue', label='Roubos de carga')
plt.plot(X, y_pred, color='red', linewidth=2, label='Regressão Linear')
plt.xlabel('Ano')
plt.ylabel('Média de Roubo de carga por Ano')
plt.title('Regressão Linear para Média de Roubo de carga')
plt.grid(True)
plt.legend()
plt.show()

# Coeficientes da regressão
print("Coeficiente angular (inclinação):", regressao.coef_[0])
print("Coeficiente linear (intercept):", regressao.intercept_)

# Converta a coluna 'ano' e 'mes' para o formato de data
data['data'] = pd.to_datetime(data['ano'].astype(str) + '-' + data['mes'].astype(str), format='%Y-%m')

latrocinios_por_mes = data.groupby('data')['latrocinio'].sum()

media_latrocinios_por_ano = latrocinios_por_mes.resample('Y').mean()

plt.figure(figsize=(10, 6))
plt.bar(media_latrocinios_por_ano.index.year, media_latrocinios_por_ano.values, color='blue')
plt.xlabel('Ano')
plt.ylabel('Média de Latrocínios por Ano')
plt.title('Média de Latrocínios por Ano')
plt.grid(True, axis='y')
plt.show()

sliced_data = data[['mes','ano','regiao','furto_celular','furto_veiculos','roubo_carga','latrocinio']]
sliced_data

import numpy as np
from google.colab import autoviz

def time_series_multiline(df, timelike_colname, value_colname, series_colname, figscale=1, mpl_palette_name='Dark2'):
  from matplotlib import pyplot as plt
  import seaborn as sns


  figsize = (10 * figscale, 5.2 * figscale)
  palette = list(sns.palettes.mpl_palette(mpl_palette_name))
  def _plot_series(series, series_name, series_index=0):
    if value_colname == 'count()':
      counted = (series[timelike_colname]
                 .value_counts()
                 .reset_index(name='counts')
                 .rename({'index': timelike_colname}, axis=1)
                 .sort_values(timelike_colname, ascending=True))
      xs = counted[timelike_colname]
      ys = counted['counts']
    else:
      xs = series[timelike_colname]
      ys = series[value_colname]
    plt.plot(xs, ys, label=series_name, color=palette[series_index % len(palette)])

  fig, ax = plt.subplots(figsize=figsize, layout='constrained')
  df = df.sort_values(timelike_colname, ascending=True)
  if series_colname:
    for i, (series_name, series) in enumerate(df.groupby(series_colname)):
      _plot_series(series, series_name, i)
    fig.legend(title=series_colname, bbox_to_anchor=(1, 1), loc='upper left')
  else:
    _plot_series(df, '')
  sns.despine(fig=fig, ax=ax)
  plt.xlabel(timelike_colname)
  plt.ylabel(value_colname)
  return autoviz.MplChart.from_current_mpl_state()

chart = time_series_multiline(sliced_data, *['ano', 'furto_celular', 'regiao'], **{})
chart

regiao = sliced_data.loc[sliced_data['regiao'] == 'Capital']
regiao

regiao.plot(kind = 'scatter',
           x = 'ano',
           y = 'furto_celular')
plt.grid()

sliced_data.plot(kind = 'scatter',
                 x = 'ano',
                 y = 'furto_celular')
plt.grid()



regiao.plot(kind ='scatter',
                 x = 'ano',
                 y = 'roubo_carga')
plt.grid()

regiao.plot(kind ='scatter',
                 x = 'ano',
                 y = 'furto_veiculos')
plt.grid()

import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt

# Leitura dos dados do arquivo CSV
dados = pd.read_csv(violencia, encoding="ISO-8859-1", sep=";")

# Dados de entrada
anos = list(range(2003, 2024))
risp = dados['risp'].unique()

# Lista de crimes (nomes das colunas no CSV)
crimes = ['furto_celular', 'roubo_carga', 'furto_veiculos']  # Substitua pelos nomes corretos das colunas

# Cálculo das médias anuais para cada crime
medias_por_crime = []

for crime in crimes:
    medias = []
    for ano in anos:
        for local in risp:
            media = dados[(dados['ano'] == ano) & (dados['risp'] == local)][crime].mean()
            medias.append(media)
    medias_por_crime.append(medias)

# Configuração dos tamanhos das bolhas (com base nas médias)
tamanhos = np.array(medias_por_crime) / np.max(medias_por_crime) * 100

# Criação do DataFrame para os dados
df = pd.DataFrame({
    'Ano': np.repeat(anos, len(risp) * len(crimes)),
    'RISP': np.tile(np.repeat(risp, len(anos)), len(crimes)),
    'Crime': [crime for _ in range(len(anos) * len(risp)) for crime in crimes],
    'Tamanho': tamanhos.flatten()
})

# Configuração do estilo do gráfico
sns.set(style="whitegrid")

# Criação do gráfico de bolhas categórico
plt.figure(figsize=(12, 8))
sns.scatterplot(data=df, x="Ano", y="RISP", hue="Crime", size="Tamanho", sizes=(50, 500), palette="viridis", alpha=0.7)

# Configuração de rótulos e título
plt.xlabel('Ano')
plt.ylabel('Localização (RISP)')
plt.title('Gráfico de Bolhas Categórico de Crimes por Ano, Localização e Tipo de Crime')

# Ajuste da legenda
handles, labels = plt.gca().get_legend_handles_labels()
plt.gca().legend(handles=handles[1:], labels=labels[1:], title="Tipo de Crime")

plt.show()

import pandas as pd
import plotly.express as px

# Leitura dos dados do arquivo CSV
dados = pd.read_csv(violencia, encoding="ISO-8859-1", sep=";")

# Dados de entrada
anos = list(range(2003, 2024))
risp = dados['risp'].unique()

# Lista de crimes (nomes das colunas no CSV)
crimes = ['furto_celular', 'roubo_carga', 'furto_veiculos']  # Substitua pelos nomes corretos das colunas

# Configuração dos tamanhos das bolhas (com base nas médias)
tamanhos = []

for crime in crimes:
    medias = []
    for ano in anos:
        for local in risp:
            media = dados[(dados['ano'] == ano) & (dados['risp'] == local)][crime].mean()
            medias.append(media)
    tamanhos.extend([media / max(medias) * 100 for media in medias])

# Criação do DataFrame para os dados
df = pd.DataFrame({
    'Ano': [ano for ano in anos for _ in range(len(risp) * len(crimes))],
    'RISP': [local for local in risp for _ in range(len(anos) * len(crimes))],
    'Crime': [crime for crime in crimes for _ in range(len(anos) * len(risp))],
    'Tamanho': tamanhos
})

# Criar um gráfico de bolhas categórico com Plotly
fig = px.scatter(df, x="Ano", y="RISP", size="Tamanho", color="Crime", hover_data=["Tamanho"],
                 color_discrete_sequence=px.colors.qualitative.Dark24, size_max=50, labels={"Tamanho": "Quantidade de Crimes"})

# Configuração de rótulos e título
fig.update_xaxes(title_text='Ano')
fig.update_yaxes(title_text='Localização (RISP)')
fig.update_layout(title='Gráfico de Bolhas Categórico de Crimes por Ano, Localização e Tipo de Crime')

# Exibir o gráfico
fig.show()

import pandas as pd
import plotly.express as px

# Leitura dos dados do arquivo CSV
dados = pd.read_csv(violencia, encoding="ISO-8859-1", sep=";")

# Dados de entrada
anos = list(range(2003, 2024))
risp = dados['risp'].unique()

# Lista de crimes (nomes das colunas no CSV)
crimes = ['furto_celular', 'roubo_carga', 'furto_veiculos']  # Substitua pelos nomes corretos das colunas

# Cálculo das quantidades totais de crimes por RISP
quantidades_totais_por_risp = []

for local in risp:
    total_por_risp = 0
    for crime in crimes:
        total_por_risp += dados[dados['risp'] == local][crime].sum()
    quantidades_totais_por_risp.append(total_por_risp)

# Criação do DataFrame para os dados
df = pd.DataFrame({
    'RISP': risp,
    'QuantidadeTotal': quantidades_totais_por_risp
})

# Normalização da quantidade total para definir a cor
df['Cor'] = (df['QuantidadeTotal'] - df['QuantidadeTotal'].min()) / (df['QuantidadeTotal'].max() - df['QuantidadeTotal'].min())

# Criar um gráfico de barras horizontais com Plotly
fig = px.bar(df, x='QuantidadeTotal', y='RISP', orientation='h',
             color_continuous_scale='Purples',
             labels={"QuantidadeTotal": "Quantidade Total de Crimes", "RISP": "Localização (RISP)"})

# Configuração de rótulos e título
fig.update_xaxes(title_text='Quantidade Total de Crimes')
fig.update_yaxes(title_text='Localização (RISP)')
fig.update_layout(title='Gráfico de Barras Horizontais de Quantidade Total de Crimes por Localização (RISP)',
                  coloraxis_colorbar_title='Intensidade de Crimes')

# Exibir o gráfico
fig.show()

import pandas as pd
import plotly.express as px

# Leitura dos dados do arquivo CSV
dados = pd.read_csv(violencia, encoding="ISO-8859-1", sep=";")

# Dados de entrada
anos = list(range(2003, 2024))
risp = dados['risp'].unique()

# Lista de crimes (nomes das colunas no CSV)
crimes = ['furto_celular', 'roubo_carga', 'furto_veiculos'] # Todas as colunas a partir da 4ª (índice 3)

# Criar um gráfico separado para cada RISP
for local in risp:
    # Filtrar os dados para o RISP atual
    dados_risp = dados[dados['risp'] == local]

    # Calcular os totais de crimes para cada crime e converter para inteiros
    totais_crimes = dados_risp[crimes].sum().astype(int)

    # Ordenar os totais de crimes em ordem decrescente
    totais_crimes = totais_crimes.sort_values(ascending=False)

    # Selecionar os 5 crimes mais frequentes
    top_5_crimes = totais_crimes.head(5)

    # Criar um DataFrame para o gráfico
    df = pd.DataFrame({'Crime': top_5_crimes.index, 'QuantidadeTotal': top_5_crimes.values})

    # Criar um gráfico de barras
    fig = px.bar(df, x='Crime', y='QuantidadeTotal', title=f'Crimes mais frequentes em {local}',
                 labels={"QuantidadeTotal": "Quantidade Total de Crimes"})

    # Exibir o gráfico
    fig.show()

import pandas as pd
import plotly.express as px

# Leitura dos dados do arquivo CSV
dados = pd.read_csv(violencia, encoding="ISO-8859-1", sep=";")

# Dados de entrada
anos = list(range(2003, 2024))
risp = dados['risp'].unique()

# Lista de crimes (nomes das colunas no CSV)
crimes = ['furto_celular', 'roubo_carga', 'furto_veiculos']

# Criar um gráfico separado para cada RISP
for local in risp:
    # Filtrar os dados para o RISP atual
    dados_risp = dados[dados['risp'] == local]

    # Calcular os totais de crimes para cada crime e converter para inteiros
    totais_crimes = dados_risp[crimes].sum().astype(int)

    # Ordenar os totais de crimes em ordem decrescente
    totais_crimes = totais_crimes.sort_values(ascending=False)

    # Criar um DataFrame para o gráfico
    df = pd.DataFrame({'Crime': totais_crimes.index, 'QuantidadeTotal': totais_crimes.values})

    # Criar um gráfico de barras
    fig = px.bar(df, x='Crime', y='QuantidadeTotal', text='QuantidadeTotal', title=f'Crimes mais frequentes em {local}',
                 labels={"QuantidadeTotal": "Quantidade Total de Crimes"})

    # Adicionar rótulos de dados em cada barra
    fig.update_traces(texttemplate='%{text}', textposition='outside')

    # Exibir o gráfico
    fig.show()

# Leitura dos dados do arquivo CSV
dados = pd.read_csv(violencia, encoding="ISO-8859-1", sep=";")

# Dados de entrada
anos = list(range(2003, 2024))
risp = dados['risp'].unique()

# Lista de crimes (nomes das colunas no CSV)
crimes = ['furto_celular', 'roubo_carga', 'furto_veiculos']  # Todas as colunas a partir da 4ª (índice 3)

# Número de linhas e colunas na grade
num_linhas = 1  # Defina o número de linhas
num_colunas = 1  # Defina o número de colunas

# Criar uma figura de subplots
fig = go.Figure()

# Criar subplots para cada RISP
for i, local in enumerate(risp):
    # Filtrar os dados para o RISP atual
    dados_risp = dados[dados['risp'] == local]

    # Calcular os totais de crimes para cada crime e converter para inteiros
    totais_crimes = dados_risp[crimes].sum().astype(int)

    # Ordenar os totais de crimes em ordem decrescente
    totais_crimes = totais_crimes.sort_values(ascending=False)

    # Selecionar os 5 crimes mais frequentes
    top_5_crimes = totais_crimes.head(5)

    # Criar um subplot na posição (i+1) na grade
    fig.add_trace(go.Bar(
        x=top_5_crimes.index,
        y=top_5_crimes.values,
        text=top_5_crimes.values,
        name=str(local),  # Converter o nome em uma string
        textposition='outside',
    ))

    # Atualizar o título do subplot
    fig.update_layout(
        title_text=f'Crimes mais frequentes em {local}',
        xaxis_title='Crimes',
        yaxis_title='Quantidade Total de Crimes',
        xaxis=dict(tickangle=0)
    )

# Atualizar o layout da grade
fig.update_layout(
    grid={'rows': num_linhas, 'columns': num_colunas},
    title_text='Grid de Gráficos com os Crimes Mais Frequentes em Cada RISP'
)

# Exibir a grade de subplots
fig.show()

import pandas as pd
import plotly.express as px

# Leitura dos dados do arquivo CSV
dados = pd.read_csv(violencia, encoding="ISO-8859-1", sep=";")

# Filtrar os dados a partir do ano de 2003
dados_roubo_carga = dados[dados['ano'] >= 2003]

# Agrupar os dados por ano e calcular a soma de 'roubo_carga'
soma_roubo_carga_por_ano = dados_roubo_carga.groupby('ano')['roubo_carga'].sum().reset_index()

# Criar um gráfico de barras empilhadas
fig = px.bar(soma_roubo_carga_por_ano, x='ano', y='roubo_carga', title='Roubo de Carga por Ano',
             labels={'roubo_carga': 'Total de Roubo de Carga', 'ano': 'Ano'},
             color='roubo_carga')

# Exibir o gráfico
fig.show()

# Carregue o arquivo CSV
dados = pd.read_csv(violencia, encoding="ISO-8859-1", sep=";")

# Verifique se há uma coluna de data e a converta para o formato datetime
anos = list(range(2003, 2023))
# Filtre os dados para o período de 2003 a 2023
start_date = pd.to_datetime('2003')
end_date = pd.to_datetime('2023')
data = dados[(anos['ano'] >= start_date) & (anos['ano'] <= end_date)]

# Contagem de ocorrências de cada tipo de crime
crime_counts = dados['roubo_carga', 'roubo_celular','roubo_veiculo', 'roubo_rua'].value_counts()

# Escolha os N principais tipos de crime para exibir no gráfico
N = 10
top_crimes = crime_counts.head(5)

# Crie um gráfico de barras para mostrar os principais crimes
plt.figure(figsize=(12, 6))
top_crimes.plot(kind='bar')
plt.title('Principais Crimes entre 2003 e 2023')
plt.xlabel('Tipo de Crime')
plt.ylabel('Número de Ocorrências')
plt.xticks(rotation=45)
plt.show()

import pandas as pd
import matplotlib.pyplot as plt

# Supondo que você tenha um DataFrame chamado 'sliced_data'
# Certifique-se de ajustar o nome do DataFrame conforme necessário

sliced_data.plot(kind='line', x='ano', y='furto_celular', marker='o', linestyle='-', color='b')
plt.title('Gráfico de Linha - Furto de Celular por Ano')
plt.xlabel('Ano')
plt.ylabel('Furto de Celular')
plt.grid()
plt.show()

import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt

# Supondo que você tenha um DataFrame chamado 'sliced_data'
# Certifique-se de ajustar o nome do DataFrame conforme necessário

# Calcular as médias de 'furto_celular' por ano
medias_por_ano = sliced_data.groupby('ano')['furto_celular'].mean().reset_index()

# Ajustar a largura das barras
largura_barras = 0.8  # Ajuste conforme necessário

# Definir paleta de cores para azul escuro
sns.set_palette("dark:blue")

# Criar o gráfico de barras com Seaborn
sns.barplot(data=sliced_data, x='ano', y='furto_celular', ci=None)

# Adicionar barras representando as médias de cada ano
sns.barplot(data=medias_por_ano, x='ano', y='furto_celular', color='orange', alpha=0.5, ci=None, linewidth=2)

# Configurações adicionais
plt.title('Médias por anos - Furto de Celular')
plt.xlabel('Ano')
plt.ylabel('Furto de Celular')
plt.grid()

# Ajustar largura do gráfico
plt.xticks(rotation=45)  # Rotaciona os rótulos do eixo x para melhor legibilidade
plt.tight_layout()  # Ajusta automaticamente a disposição do gráfico

# Exibir o gráfico
plt.show()

import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt

# Supondo que você tenha um DataFrame chamado 'sliced_data'
# Certifique-se de ajustar o nome do DataFrame conforme necessário

# Calcular as médias de 'latrocinio' por ano
medias_por_ano = sliced_data.groupby('ano')['latrocinio'].mean().reset_index()

# Ajustar a largura das barras
largura_barras = 0.8  # Ajuste conforme necessário

# Definir a paleta de cores como "rocket"
palette = sns.color_palette("rocket")

# Criar o gráfico de barras com Seaborn
sns.barplot(data=sliced_data, x='ano', y='latrocinio', ci=None, palette=palette)

# Adicionar barras representando as médias de cada ano
sns.barplot(data=medias_por_ano, x='ano', y='latrocinio', color='orange', alpha=0.5, ci=None, linewidth=2)

# Configurações adicionais
plt.title('Gráfico de Barras - Latrocínio por Ano com Médias')
plt.xlabel('Ano')
plt.ylabel('Latrocínio')
plt.grid()

# Ajustar largura do gráfico
plt.xticks(rotation=45)  # Rotaciona os rótulos do eixo x para melhor legibilidade
plt.tight_layout()  # Ajusta automaticamente a disposição do gráfico

# Exibir o gráfico
plt.show()

import pandas as pd
import plotly.express as px
import plotly.graph_objects as go

# Leitura dos dados do arquivo CSV
dados = pd.read_csv(violencia, encoding="ISO-8859-1", sep=";")

# Filtrar os dados a partir do ano de 2003
dados_roubo_carga = dados[dados['ano'] >= 2003]

# Agrupar os dados por ano e calcular a soma de 'roubo_carga'
soma_roubo_carga_por_ano = dados_roubo_carga.groupby('ano')['roubo_carga'].sum().reset_index()

# Criar um gráfico de barras verticais
fig = px.bar(soma_roubo_carga_por_ano, x='ano', y='roubo_carga',
             title='Roubo de Carga por Ano',
             labels={'roubo_carga': 'Total de Roubo de Carga', 'ano': 'Ano'},
             color='roubo_carga')

# Personalizar o eixo y para exibir todos os anos
fig.update_yaxes(tickmode='array', tickvals=soma_roubo_carga_por_ano['ano'], ticktext=soma_roubo_carga_por_ano['ano'])

# Exibir o gráfico
fig.show()